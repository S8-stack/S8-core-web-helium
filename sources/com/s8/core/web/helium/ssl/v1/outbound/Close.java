package com.s8.core.web.helium.ssl.v1.outbound;

import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLEngineResult.Status;

class Close implements SSL_Outbound.Operation {

	@Override
	public void operate(SSL_Outbound out) {

		/*
		 * Closing this side of the engine
		 */
		out.engine.closeOutbound();


		/* wrapping */
		try {
			boolean isWrapCompleted = false;
			while(!isWrapCompleted) {

				/*
				 * (JAVA doc) states that:
				 * 
				 * In all cases, closure handshake messages are generated by the engine, and
				 * wrap() should be repeatedly called until the resulting SSLEngineResult's
				 * status returns "CLOSED", or isOutboundDone() returns true.
				 * 
				 */
				/* wrapping */
				SSLEngineResult result = out.engine.wrap(out.applicationBuffer, out.networkBuffer);

				if(out.SSL_isVerbose) {
					System.out.println("[SSL_Outbound] : "+result);
				}

				// end point listening to result for updating phase
				out.getConnection().onResult(result);

				if(result.getStatus()==Status.CLOSED || out.engine.isOutboundDone() || result.bytesProduced()==0) {
					isWrapCompleted = true;
				}
			}

			/*
			 * All data obtained from the wrap() method should be sent to the peer.
			 */
			out.pushOp(new Flush());
		}
		catch (SSLException e) {
			e.printStackTrace();
		}
	}

}
